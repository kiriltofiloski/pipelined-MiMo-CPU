@this is a revised example showing the efficiency of a 2-bit predictor over a 1-bit predictor
@ on nested loop

.text

mov r0, #8

loop: 
mov r1, #8

repeat:
subs r1, r1, #1
bne repeat
add r0, r0, #1
b  loop

/*
The conditional loop (bne repeat) runs 8 times. The 1-bit predictor fails on first loop enter then fails again on loop exit.
Every next loop it fails twice on loop enter and exit, so out of every 8 predictions, 2 are failures, out of 24 predictions, 6 are failures
The 2-bit predictor fails twice on first loop enter because it's starting value is 00(Strong Not Taken).
It fails once on loop exit because it's value is 11(Strong Taken). 
On loop reenter it succeeds because it's value is 10(Weak Taken)
Out of every 8 predictions, 1 is a failure. Out of 24 predictions 5 are failures (1*3 + 2 at the beginning).
*/

/*
using no prediction(branch not taken): 21/24 predictions are incorrect
using 1-bit predictor: 6/24 predictions are incorrect
using 2-bit predictor: 5/24 predictions are incorrect
using correlating LHT: 13/24 incorrect
using correlating 2 by 2: 10/24 incorrect
using tournament: 13/24 incorrect
*/